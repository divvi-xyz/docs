#!/usr/bin/env ts-node

import * as fs from "fs";
import * as path from "path";
import type { MintConfig, Navigation, NavigationGroup } from "@mintlify/models";

interface SubmoduleConfig {
  name: string;
  source: string; // Path relative to project root
  dest: string; // Path relative to docs directory
  docsConfig?: string; // Path to docs.json relative to source
}

// Configuration for submodules to include
const SUBMODULES: SubmoduleConfig[] = [
  {
    name: "protocol",
    source: "submodules/divvi-protocol/docs",
    dest: "protocol",
    docsConfig: "docs.json",
  },
  // Add more submodules here as needed:
  // {
  //   name: "mobile",
  //   source: "submodules/divvi-mobile/docs",
  //   dest: "mobile",
  //   docsConfig: "docs.json"
  // }
];

const ROOT_DIR = path.join(__dirname, "..");
const BASE_CONFIG_PATH = path.join(ROOT_DIR, "docs", "docs-base.json");
const OUTPUT_PATH = path.join(ROOT_DIR, "docs", "docs.json");

function readJsonFile(filePath: string): MintConfig {
  try {
    const content = fs.readFileSync(filePath, "utf-8");
    return JSON.parse(content);
  } catch (error) {
    console.error(`Error reading ${filePath}:`, error);
    throw error;
  }
}

function writeJsonFile(filePath: string, data: MintConfig): void {
  try {
    const content = JSON.stringify(data, null, 2);
    fs.writeFileSync(filePath, content, "utf-8");
    console.log(`‚úÖ Successfully generated ${filePath}`);
  } catch (error) {
    console.error(`Error writing ${filePath}:`, error);
    throw error;
  }
}

function prependPrefix(
  group: NavigationGroup,
  prefix: string
): NavigationGroup {
  return {
    ...group,
    pages: group.pages.map((entry) =>
      typeof entry === "string"
        ? `${prefix}/${entry}`
        : prependPrefix(entry, prefix)
    ),
  };
}

function copyDirectory(src: string, dest: string, submoduleName: string): void {
  try {
    // Remove existing directory/symlink
    if (fs.existsSync(dest)) {
      fs.rmSync(dest, { recursive: true, force: true });
    }

    // Copy directory recursively using built-in Node.js method
    fs.cpSync(src, dest, {
      recursive: true,
      force: true,
      preserveTimestamps: true,
    });

    // Add warning file to indicate content is auto-generated
    const relativeSrc = path.relative(ROOT_DIR, src);
    const warningContent = `# ‚ö†Ô∏è AUTO-GENERATED DIRECTORY

**DO NOT EDIT FILES IN THIS DIRECTORY**

This directory and its contents are automatically copied from the submodule:
\`${relativeSrc}\`

## How to make changes:

1. Edit files in the submodule: \`${relativeSrc}\`
2. Run \`npm run generate-docs\` to regenerate this directory
3. Changes made directly in this directory will be overwritten

## Generated by:
- Script: \`scripts/generate-docs.ts\`
- Source: \`${relativeSrc}\`
`;

    const warningPath = path.join(dest, "README-AUTO-GENERATED.md");
    fs.writeFileSync(warningPath, warningContent, "utf-8");

    console.log(
      `üìÅ Copied ${submoduleName}: ${relativeSrc} ‚Üí ${path.relative(
        ROOT_DIR,
        dest
      )}`
    );
  } catch (error) {
    console.error(`Error copying directory ${src}:`, error);
    throw error;
  }
}

function copySubmoduleFiles(): void {
  for (const submodule of SUBMODULES) {
    const sourceDir = path.join(ROOT_DIR, submodule.source);
    const destDir = path.join(ROOT_DIR, "docs", submodule.dest);

    if (!fs.existsSync(sourceDir)) {
      console.warn(
        `‚ö†Ô∏è  Submodule source directory not found: ${submodule.source} (skipping)`
      );
      continue;
    }

    copyDirectory(sourceDir, destDir, submodule.name);
  }
}

function generateDocs(): void {
  console.log("üîÑ Generating docs.json...");

  // Copy submodule files (replaces symlinks)
  console.log("üìÅ Copying submodule files...");
  copySubmoduleFiles();

  // Validate base config exists
  if (!fs.existsSync(BASE_CONFIG_PATH)) {
    throw new Error(`Base config file not found: ${BASE_CONFIG_PATH}`);
  }

  // Read base configuration
  const baseConfig = readJsonFile(BASE_CONFIG_PATH);
  console.log(`üìñ Read base config: ${Object.keys(baseConfig).length} keys`);

  // Start with base config
  let mergedConfig: MintConfig = { ...baseConfig };
  const baseNav: Navigation = Array.isArray(baseConfig.navigation)
    ? baseConfig.navigation
    : (baseConfig.navigation as any)?.groups || [];

  let allNavigation: Navigation = [...baseNav];

  // Process each submodule
  for (const submodule of SUBMODULES) {
    const configPath = path.join(
      ROOT_DIR,
      "docs",
      submodule.dest,
      submodule.docsConfig || "docs.json"
    );

    if (fs.existsSync(configPath)) {
      const submoduleConfig = readJsonFile(configPath);
      console.log(
        `üìñ Read ${submodule.name} config: ${
          Object.keys(submoduleConfig).length
        } keys`
      );

      // Extract navigation from submodule
      const subNav: Navigation = Array.isArray(submoduleConfig.navigation)
        ? submoduleConfig.navigation
        : (submoduleConfig.navigation as any)?.groups || [];

      // Add prefixed navigation
      const prefixedNav = subNav.map((group) =>
        prependPrefix(group, submodule.dest)
      );
      allNavigation.push(...prefixedNav);
    } else {
      console.warn(
        `‚ö†Ô∏è  No docs config found for ${submodule.name} at ${path.relative(
          ROOT_DIR,
          configPath
        )}`
      );
    }
  }

  // Update merged config with all navigation
  mergedConfig.navigation = { groups: allNavigation } as any;

  // Log the merged navigation structure
  console.log("üìã Merged navigation structure:");
  allNavigation.forEach((group: any) => {
    console.log(`  üìÅ ${group.group}:`);
    group.pages.forEach((page: any) => {
      console.log(`    üìÑ ${typeof page === "string" ? page : "[nested]"}`);
    });
  });

  // Write the merged configuration
  writeJsonFile(OUTPUT_PATH, mergedConfig);

  console.log("‚ú® docs generation complete!");
}

// CLI execution
if (require.main === module) {
  try {
    generateDocs();
  } catch (error) {
    console.error("‚ùå Error generating docs:", error);
    process.exit(1);
  }
}
