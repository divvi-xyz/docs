---
title: "Key Concepts"
description: " "
---

Before diving into advanced SDK usage, it’s important to understand a few key concepts and patterns central to Sage Protocol and its SDK. This section covers essential architectural and usage details to ensure a smooth integration process.

## Application Isolation and Context (`appId`)

Sage Protocol isolates content and interactions per application by using a unique identifier (`appId`). Each application maintains distinct channels and posts, while user identities and social graphs remain global across all Sage-compatible apps.

**What this means for you**:

- Users have one global identity and consistent social relationships everywhere.
- Each app provides distinct, tailored content experiences to its community.

**Example of using appId when initializing the Sage SDK**:

```typescript
const sageClient = new SageClient({
  appId: '0x123...', // Unique identifier for your application
  channelRegistryId: '0x456...', // Registry managing channels for this specific app
  network: 'testnet' // or 'mainnet'
});
```

This setup clearly demonstrates how each application uses a distinct context (`appId`) to maintain content isolation while benefiting from global user identities and relationships.

## Invite-Based User Creation (Temporary)

Currently, Sage Protocol requires invite codes and keys for new user creation. Invite-based onboarding helps applications manage and control initial growth and user engagement quality.

- **Invite Code**: A unique code to authorize user creation.
- **Invite Key**: A secure key provided alongside the invite code.

_(Note: Future protocol versions will make invite codes optional.)_

## Transaction Patterns

All Sage SDK operations that write data to the blockchain follow a clear two-step process:

1. **Construct Transaction**:\
   SDK methods generate and return transaction objects ready to be signed.
2. **Sign and Execute Transaction**:\
   Your application handles user wallet interactions to securely sign and execute these transactions.

**Example workflow:**

```javascript
const result = await sageClient.createUser({
  amounts: [0, 0],
  avatar: 0, // optional avatar blob ID
  banner: 0, // optional banner blob ID
  description: "Web3 enthusiast",
  inviteCode: "your-invite-code",
  inviteKey: "your-invite-key",
  name: "john-doe",
  self: walletAddress
});

if (result.ok) {
  await signAndExecuteTransaction({ transaction: result.transaction });
} else {
  console.error('Error:', result.err);
}
```

This separation ensures security and user transparency for all blockchain interactions.

## Error Handling

The Sage SDK consistently returns structured results indicating success or error states. Every SDK operation returns a result object containing:

- `ok`: A boolean indicating success (`true`) or failure (`false`).
- `err`: Contains error details if the transaction fails.

**Use the following recommended handling pattern:**

```javascript
const result = await sageClient.someAction({ /* parameters */ });

if (result.ok) {
  await signAndExecuteTransaction({ transaction: result.transaction });
} else {
  console.error('Error:', result.err);
}
```

Always verify transactions by checking the `ok` property before proceeding.

## Event Monitoring and Querying

The Sage SDK provides powerful event-monitoring capabilities. Events (such as user creation, posting, and channel updates) are emitted explicitly onchain, enabling:

- Real-time responsiveness in your app.
- Precise analytics and user activity tracking.

**Example usage (monitoring new user registrations)**:

```javascript
// Monitor new user creation events
const result = await sageClient.queryUserCreateEvents({});

result.events.forEach(event => {
  console.log(`New user created: ${event.userName} (User ID: ${event.userId})`);
  console.log(`Owned User ID: ${event.userOwnedId}, Shared User ID: ${event.userSharedId}`);
  if (event.referredBy) {
    console.log(`Referred by user ID: ${event.referredBy}`);
  }
});

// Continue querying from the last event fetched
if (result.hasNextPage) {
  const nextBatch = await sageClient.queryUserCreateEvents({
    cursor: result.nextCursor
  });
}
```

## React Context and Hooks

For React applications, Sage SDK provides built-in context and custom React hooks (`useUser`, `useChannel`, `usePost`). These simplify integration and state management, improving developer experience.

**Example using** `useChannel`:

```javascript
import { useChannel } from '@sageprotocol/sdk/react';

function ChannelComponent({ channelId, userContext }) {
  const { follow } = useChannel();

  const handleFollow = async () => {
    const result = await follow({
      amounts: [0, 0],
      channelId,
      ownedUserId: userContext.ownedUserId,
      self: userContext.walletAddress
    });

    if (result.ok) {
      await signAndExecuteTransaction({ transaction: result.transaction });
    } else {
      console.error(result.err);
    }
  };

  return <button onClick={handleFollow}>Follow Channel</button>;
}
```

Using hooks simplifies interactions with Sage primitives and maintains clean, readable code.

## Next Steps

With the key concepts clear, you’re ready to explore Sage SDK’s powerful core primitives and fully leverage decentralized social experiences. Next, continue to:

- Learn detailed management of the core primitives:
  - Users
  - Channels
  - Posts
- [Advanced Guides](#): See complete examples for building sophisticated decentralized social apps.
- [**API Reference**](#): Explore comprehensive details on SDK methods and capabilities.